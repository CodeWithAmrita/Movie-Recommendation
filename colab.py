#This code is to be carried out in google colab line by line. 
#It is present here only for theoritical purposes to give an overview of the project.

# -*- coding: utf-8 -*-
"""Movie Recommendation

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XF9Jv2dO-QuBLetmgvrHAfp1TxPyptWq
"""

from google.colab import files
files.upload()

#The following ar the commands only to be carried out in google colab. 
!pip install kaggle

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

!chmod 600 ~/.kaggle/kaggle.json
#api command

!kaggle datasets download -d tmdb/tmdb-movie-metadata

!ls

!unzip tmdb-movie-metadata.zip

!ls

#The actual python code starts from here

import csv
import pandas as pd

df1 = pd.read_csv("tmdb_5000_credits.csv")
df2 = pd.read_csv("tmdb_5000_movies.csv")

df1.head()

#Prints the first five rows

df2.head()

#Merging df1 and df2 in the df2 file

df1.columns = ['id','tittle','cast','crew']
df2= df2.merge(df1,on='id')

df2.head(3)

"""**Demographic Filtering**"""

#Calculating the mean of the heading 'vote_average'

C = df2["vote_average"].mean()
print(C)

#Finding the quantile (percentage)

m = df2["vote_count"].quantile(0.9)
print(m)

#Making a copy of df2 and located (loc) vote count
#And then finding out movies whose vote count is greater than m

q_movies = df2.copy().loc[df2["vote_count"] >= m]

#shape - Prints out (number of rows, number of columns)
q_movies.shape

#x represents the movies each
#Storing vote count in v and vote average in R
#After calculating the value from the formul return it and catch it into the same data frame with a new column "Score"
#axis = 1, because we're applying it in a vertical order

def weighted_rating(x, m = m, C = C):
  v = x["vote_count"]
  R = x["vote_average"]
  return (v/(v+m) * R) + (m/(m+v) * C)

q_movies["Score"] = q_movies.apply(weighted_rating, axis = 1)

q_movies.head()

#Sorting the score in descending order
#ascending = True will make it ascending

q_movies = q_movies.sort_values("Score", ascending = False)

q_movies.head(10)

#Only printing the headings we want

q_movies[['title', 'vote_count', 'vote_average', 'Score']].head(10)

#Coverting it into csv file names Top Movies

q_movies[['title', 'vote_count', 'vote_average', 'Score']].to_csv("Top_movies.csv")

"""Content based filtering"""

df2[['title', 'cast', 'crew', 'keywords', 'genres']].head(3)

from ast import literal_eval

#Storing the headers in an array

featured = ['cast', 'crew', 'keywords', 'genres']

#Applying the literal_eval function of the headers of df2 and storing in the same place
for i in featured:
  df2[i] = df2[i].apply(literal_eval)

df2.dtypes

#Making a function sending the crew information the ()
#Then finding the name of all directors by the for loop

def get_director(movie_crew_info):
  for i in movie_crew_info:
    a = i.split('"')

    print(a)


df2["crew"].apply(get_director)

df2[['title', 'cast', 'director', 'keywords', 'genres']].to_csv("csv2.csv")